"<p>Give example of a scenario where <code>System.child_spec/2</code> function might be useful:</p><blockquote><p><code>Supervisor.child_spec/2</code> is a function for explicitly building and overriding child specification.</p><p>Similar to <code>start_link/2</code> and <code>init/2</code>, it expects a module, <code>{module, arg}</code>, or a child specification map. If a two-element tuple in the shape of <code>{module, arg}</code> is given, the child specification is retrieved by calling <code>module.child_spec(arg)</code>. If a module is given, the child specification is retrieved by calling <code>module.child_spec([])</code>.</p><p>After the child specification is retrieved, the fields on overrides are directly applied on the child spec. If overrides has keys that do not map to any child specification field, an error is raised.</p></blockquote>","<p>Scenario where a supervisor needs to start multiple processes with the same default child specs (e.g. multiple identical GenServer workers). For example:</p><div class=""sourceCode"" id=""cb1""><pre class=""sourceCode elixir""><code class=""sourceCode elixir""><span id=""cb1-1""><a href=""#cb1-1"" aria-hidden=""true""></a><span class=""kw"">def</span> start_link(_) <span class=""kw"">do</span></span>
<span id=""cb1-2""><a href=""#cb1-2"" aria-hidden=""true""></a>    <span class=""cn"">File</span><span class=""op"">.</span>mkdir_p!(<span class=""ot"">@db_folder</span>)</span>
<span id=""cb1-3""><a href=""#cb1-3"" aria-hidden=""true""></a>    children <span class=""op"">=</span> <span class=""cn"">Enum</span><span class=""op"">.</span>map(<span class=""dv"">1</span><span class=""op"">..</span><span class=""ot"">@pool_size</span>, <span class=""op"">&amp;</span>worker_spec<span class=""op"">/</span><span class=""dv"">1</span>)</span>
<span id=""cb1-4""><a href=""#cb1-4"" aria-hidden=""true""></a>    <span class=""cn"">Supervisor</span><span class=""op"">.</span>start_link(children, <span class=""va"">strategy:</span> <span class=""va"">:one_for_one</span>)</span>
<span id=""cb1-5""><a href=""#cb1-5"" aria-hidden=""true""></a><span class=""kw"">end</span></span>
<span id=""cb1-6""><a href=""#cb1-6"" aria-hidden=""true""></a></span>
<span id=""cb1-7""><a href=""#cb1-7"" aria-hidden=""true""></a><span class=""ot"">@doc</span> <span class=""st"">&quot;Override worker ID in default worker child spec&quot;</span></span>
<span id=""cb1-8""><a href=""#cb1-8"" aria-hidden=""true""></a><span class=""kw"">defp</span> worker_spec(worker_id) <span class=""kw"">do</span></span>
<span id=""cb1-9""><a href=""#cb1-9"" aria-hidden=""true""></a>    default_worker_spec <span class=""op"">=</span> {<span class=""cn"">Todo</span><span class=""op"">.</span><span class=""cn"">DatabaseWorker</span>, {<span class=""ot"">@db_folder</span>, worker_id}}</span>
<span id=""cb1-10""><a href=""#cb1-10"" aria-hidden=""true""></a>    <span class=""cn"">Supervisor</span><span class=""op"">.</span>child_spec(default_worker_spec, <span class=""va"">id:</span> worker_id)</span>
<span id=""cb1-11""><a href=""#cb1-11"" aria-hidden=""true""></a><span class=""kw"">end</span></span></code></pre></div><p>In the above example we want to create multiple copies of a GenServer worker, each with the same default spec. By mapping them over <code>Supervisor.child_spec</code>, we can parametrize each spec in <code>worker_spec/1</code> function.</p>",supervisor genserver
"<p>Given the following code, list dates with the same appointments.</p><div class=""sourceCode"" id=""cb1""><pre class=""sourceCode elixir""><code class=""sourceCode elixir""><span id=""cb1-1""><a href=""#cb1-1"" aria-hidden=""true""></a><span class=""va"">:ets</span><span class=""op"">.</span>new(<span class=""va"">:todo_list</span>, [<span class=""va"">:bag</span>, <span class=""va"">:named_table</span>]) <span class=""co""># =&gt; :todo_list</span></span>
<span id=""cb1-2""><a href=""#cb1-2"" aria-hidden=""true""></a><span class=""va"">:ets</span><span class=""op"">.</span>insert(<span class=""va"">:todo_list</span>, {<span class=""op"">~</span>D[<span class=""dv"">2018-05-24</span>], <span class=""st"">&quot;Dentist&quot;</span>}) <span class=""co""># =&gt; true</span></span>
<span id=""cb1-3""><a href=""#cb1-3"" aria-hidden=""true""></a><span class=""va"">:ets</span><span class=""op"">.</span>insert(<span class=""va"">:todo_list</span>, {<span class=""op"">~</span>D[<span class=""dv"">2018-05-24</span>], <span class=""st"">&quot;Shopping&quot;</span>}) <span class=""co""># =&gt; true</span></span>
<span id=""cb1-4""><a href=""#cb1-4"" aria-hidden=""true""></a><span class=""va"">:ets</span><span class=""op"">.</span>insert(<span class=""va"">:todo_list</span>, {<span class=""op"">~</span>D[<span class=""dv"">2018-05-30</span>], <span class=""st"">&quot;Haircut&quot;</span>}) <span class=""co""># =&gt; true</span></span>
<span id=""cb1-5""><a href=""#cb1-5"" aria-hidden=""true""></a><span class=""va"">:ets</span><span class=""op"">.</span>insert(<span class=""va"">:todo_list</span>, {<span class=""op"">~</span>D[<span class=""dv"">2018-05-24</span>], <span class=""st"">&quot;Haircut&quot;</span>}) <span class=""co""># =&gt; true</span></span></code></pre></div>","<div class=""sourceCode"" id=""cb1""><pre class=""sourceCode elixir""><code class=""sourceCode elixir""><span id=""cb1-1""><a href=""#cb1-1"" aria-hidden=""true""></a><span class=""va"">:ets</span><span class=""op"">.</span>match_object(<span class=""va"">:todo_list</span>, {<span class=""va"">:_</span>, <span class=""st"">&quot;Haircut&quot;</span>})</span>
<span id=""cb1-2""><a href=""#cb1-2"" aria-hidden=""true""></a><span class=""co""># =&gt; [{~D[2018-05-30], &quot;Haircut&quot;}, {~D[2018-05-24], &quot;Haircut&quot;}]</span></span></code></pre></div><p>The function <code>:ets.match_object/2</code> accepts a match pattern - a tuple that describes the shape of the row. The atom <code>:_</code> indicates that you accept any value, so the pattern <code>{:_, ""Dentist""}</code> essentially matches all rows where the second element is <code>""Dentist""</code>.</p>",ETS exercise
"<p>What is the output of the following code?</p><div class=""sourceCode"" id=""cb1""><pre class=""sourceCode elixir""><code class=""sourceCode elixir""><span id=""cb1-1""><a href=""#cb1-1"" aria-hidden=""true""></a>spawn(<span class=""kw"">fn</span> <span class=""op"">-&gt;</span></span>
<span id=""cb1-2""><a href=""#cb1-2"" aria-hidden=""true""></a>  spawn_link (<span class=""kw"">fn</span> <span class=""op"">-&gt;</span></span>
<span id=""cb1-3""><a href=""#cb1-3"" aria-hidden=""true""></a>      <span class=""cn"">Process</span><span class=""op"">.</span>sleep(<span class=""dv"">1000</span>)</span>
<span id=""cb1-4""><a href=""#cb1-4"" aria-hidden=""true""></a>      <span class=""cn"">IO</span><span class=""op"">.</span>puts(<span class=""st"">&quot;Process 2 finished&quot;</span>)</span>
<span id=""cb1-5""><a href=""#cb1-5"" aria-hidden=""true""></a>  <span class=""kw"">end</span>)              <span class=""op"">|</span></span>
<span id=""cb1-6""><a href=""#cb1-6"" aria-hidden=""true""></a>    <span class=""cf"">raise</span>(<span class=""st"">&quot;Something went wrong in Process 1&quot;</span>)</span>
<span id=""cb1-7""><a href=""#cb1-7"" aria-hidden=""true""></a><span class=""kw"">end</span>)</span></code></pre></div>","<div class=""sourceCode"" id=""cb1""><pre class=""sourceCode elixir""><code class=""sourceCode elixir""><span id=""cb1-1""><a href=""#cb1-1"" aria-hidden=""true""></a><span class=""co"">#PID&lt;0.140.0&gt;  15:00:40.443 [error] Process                           </span></span>
<span id=""cb1-2""><a href=""#cb1-2"" aria-hidden=""true""></a>ong <span class=""kw"">in</span> <span class=""cn"">Process</span> <span class=""dv"">1</span>     (stdlib) erl_eval<span class=""op"">.</span><span class=""va"">erl:</span><span class=""dv"">678</span>: <span class=""va"">:erl_eval</span><span class=""op"">.</span>do_apply<span class=""op"">/</span><span class=""dv"">6</span></span></code></pre></div><p><code>spawn_link/1</code> connects exactly two processes and is always bidirectional. Even though Process2 is sleeping, because Process 1 terminated abnormally, which caused an exit signal emitted to Process 2; As a result Process 2 exits as well.</p>",processes
"<p>What is the result of the following two invocations?</p><div class=""sourceCode"" id=""cb1""><pre class=""sourceCode elixir""><code class=""sourceCode elixir""><span id=""cb1-1""><a href=""#cb1-1"" aria-hidden=""true""></a>spawn_link(<span class=""kw"">fn</span> <span class=""op"">-&gt;</span> <span class=""cn"">Process</span><span class=""op"">.</span>sleep(<span class=""dv"">4000</span>); <span class=""cn"">IO</span><span class=""op"">.</span>puts(<span class=""st"">&quot;ending&quot;</span>) <span class=""kw"">end</span>)</span>
<span id=""cb1-2""><a href=""#cb1-2"" aria-hidden=""true""></a>spawn_link(<span class=""kw"">fn</span> <span class=""op"">-&gt;</span> <span class=""cn"">Process</span><span class=""op"">.</span>sleep(<span class=""dv"">4000</span>); <span class=""cf"">raise</span>(<span class=""st"">&quot;ending&quot;</span>) <span class=""kw"">end</span>)</span></code></pre></div>","<p>First one prints <code>""ending""</code> after 4 seconds and gracefully exits. Second one causes the child process to quit abnormally, which causes the parent process in this case (IEx shell) to exit as well.</p><pre><code>Process #PID&lt;0.147.0&gt; raised an exception ** (RuntimeError) ending
(stdlib) erl_eval.erl:678: :erl_eval.do_apply/6</code></pre>",processes
"<p>When you start your BEAM instance with the <code>--hidden</code> argument, the node isn’t seen in other nodes’ connected lists (and vice versa). In what scenario, this is useful?</p>","<p>A simple example is starting a local node that acts as a remote shell to another node. Another example is an instrumentation tool - a node that connects to another node, collects all sorts of metrics from it, and presents the results in a GUI.</p><p>Such nodes are helpers that shouldn’t be part of the cluster, and you usually don’t want them to be seen as such. For this purpose, you can make a hidden connection</p>",distribution
"<p>In the following code, why is the ETS table wrapped in GenServer? Why there’s no callback code for get and put?</p><pre><code>defmodule ETSKeyValue do
    use GenServer
    
    def start_link() do
        GenServer.start_link(__MODULE__, nil, name: __MODULE__)
    end
    
    def init(_) do
        :ets.new(__MODULE__, [:named_table, :public, write_concurrency: true])
        {:ok, nil}
    end
    
    def put(key, value) do
        :ets.insert(__MODULE__, {key, value})
    end
    
    def get(key) do
        case :ets.lookup(__MODULE__, key) do
            [{^key,value}] -&gt; value
            [] -&gt; nil
        end
    end
end</code></pre>","<ol type=""1""><li><p>An ETS table is deeply connected to its owner process (by default, the process that created the table). If the owner process terminates, the ETS table is reclaimed. So the sole purpose of this GenServer process is to keep the table alive.</p></li><li><p>Get and put operations now don’t go through the server process. This means that multiple clients can work with the key/value store simultaneously, without blocking each other.</p></li></ol>",ets genserver
"<p>Why is the following error thrown?</p><pre><code>table = :ets.new(:my_table, [])
# =&gt; #Reference&lt;0.4030288514.1534984196.194401&gt;
:ets.insert(table, {:key_1,1})
# =&gt; true
spawn(fn -&gt; :ets.insert(table, {:key_3, 3}) end)
# =&gt; #PID&lt;0.113.0&gt;
# Process #PID&lt;0.113.0&gt; raised an exception ** (ArgumentError) argument error (stdlib)
:ets.insert(#Reference&lt;0.4030288514.1534984196.194401&gt;, {:key_3, 3})
# =&gt; nil</code></pre>","<p>ETS table’s have by default <strong>protected</strong> access permissions and only the owner process can read from and write to the table. All other processes can only read from the table. You can fix it by making the table access to public.</p><pre><code>table = :ets.new(:table, [:public]) 
# =&gt; #Reference&lt;0.4030288514.1534984196.194527&gt;
spawn(fn -&gt; :ets.insert(table, {:key_3, 5}) end)
# =&gt; #PID&lt;0.123.0&gt;
:ets.lookup(table, :key_3)
# =&gt; [key_3: 5]</code></pre><p>Here are the table access permissions:</p><ul><li><code>protected</code> - The default. The owner process can read from and write to the table. All other processes can read from the table.</li><li><code>public</code> - All processes can read from and write to the table.</li><li><code>private</code> - Only the owner process can access the table.</li></ul>",ets
"<p>Elixir allows you to define you child spec as part of your module if you don’t want to use the default <a href=""https://hexdocs.pm/elixir/GenServer.html""><code>child_spec</code></a> provided by <code>GenServer</code>. For example:</p><pre><code>defmodule Stack do
    use GenServer
    
    def start_link(state) do
        GenServer.start_link(__MODULE__, state, name: __MODULE__)
    end
    
    def child_spec(arg) do
        %{id: Stack, start: {Stack, :start_link, [arg]}}
    end

    ... 
end</code></pre><p>How do you override this child spec when starting the supervisor?</p>","<p>If you need to convert a tuple or a module child specification to a map or modify a child specification, you can use the <a href=""https://hexdocs.pm/elixir/Supervisor.html#child_spec/2""><code>Supervisor.child_spec/2</code></a> function. For example, to run the stack with a different <code>:id</code> and a <code>:shutdown</code>:</p><pre><code>children = [Supervisor.child_spec({Stack, [:hello]}, id: MyStack, shutdown: 10_000)]
Supervisor.start_link(children, strategy: :one_for_one)</code></pre>",supervisor
"<p>What are guard clauses?</p>","<p>Guard clauses are a way to augment pattern matching with more complex checks. They are allowed in a predefined set of constructs where pattern matching is allowed. They are predicates, which are used to conditionally invoke function clauses.</p><p>Not all expressions are allowed in guard clauses, but only a handful of them. This is a deliberate choice. This way, Elixir (and Erlang) can make sure that nothing bad happens while executing guards and no mutations happen anywhere. It also allows the compiler to optimize the code related to guards efficiently.</p><pre><code>defmodule Factorial do
    def of(0), do: 1
    
    def of(n) when n &gt; 0 do
        n * of(n-1)
    end
end</code></pre>",
"<p>When a supervisor is terminated, where do you specify the strategy to handle children processes?</p>","<p>In <code>Supervisor.start_link(child_spec, options)</code> as part of the options. For example:</p><pre><code>Supervisor.start_link( [Todo.ProcessRegistry, T
odo.Cache, Todo.Database], strategy: :one_for_one, shutdown: 10_000)</code></pre><p>When a supervisor process terminates, it will instruct its children to terminate gracefully, thus giving them the chance to do final cleanup. If some of those children are themselves supervisors, they will take down their own trees in the same way. Graceful termination of a GenServer worker involves invoking the <code>terminate/2</code> callback, but only if the worker process is trapping exits. Because graceful termination involves the possible execution of cleanup code, it may take longer than desired. The <code>:shutdown</code> option in a child specification lets you control how long the supervisor will wait for the child to terminate gracefully. Possible values for <code>:shutdown</code> are:</p><ul><li>time specified in milliseconds</li><li><code>:infinity</code> - instructs the supervisor to wait indefinitely for the child to terminate</li><li><code>:brutal_kill</code> - tells the supervisor to immediately terminate the child in a forceful way</li></ul><p>The default value of the <code>:shutdown</code> option is 5000ms for a worker process or <code>:infinity</code> for a supervisor process.</p>",supervisor
